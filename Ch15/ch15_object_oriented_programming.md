# 面向对象程序设计
## 15.1 OOP：概述
面向对象的基础是数据抽象、继承和动态绑定。通过数据抽象，我们将类的接口与实现分离；通过继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象
- 继承
基类与派生类
我们将定义两个类，Quote与派生类Bulk_quote
``` C++
class Quote {
  public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};

class Bulk_quote : public Quote {
  public:
    double net_price(std::size_t) const override;
};
```
对于基类允许派生类重新定义的函数，我们声明为虚函数，即在前面加上virtual。在派生类中重新定义虚函数时可以在最后加上virtual来注明他使用这个成员函数来改写基类的虚函数。
- 动态绑定
``` C++
double print_total(ostream &os, const Quote &item, size_t n)
{
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn()
     << " # sold: " << n << " total due: " << ret << endl;
  return ret;
}
```
调用这个函数，当传入基类对象时，调用的是基类的net_price，传入派生类对象，则调用派生类的对应函数
当我们使用基类的引用或指针调用一个虚函数时发生动态绑定
## 15.2 定义基类和派生类
### 15.2.1 定义基类
### 15.2.2 定义派生类
### 15.2.3 类型转换与继承
## 15.3 虚函数
## 15.4 抽象基类
纯虚函数
## 15.5 访问控制和继承
- 受保护的成员
- 公有、私有和保护继承
- 派生类向基类转换的可访问性
- 友元和继承
- 改变个别成员的可访问性
- 默认的继承保护级别
## 15.6 继承中的类作用域
- 在编译时进行名字查找
- 名字冲突与继承
- 通过作用域运算符类使用隐藏的成员
- 一如往常，名字查找先于类型检查
- 虚函数与作用域
- 通过基类调用隐藏的虚函数
- 覆盖重载的函数
## 15.7 构造函数和拷贝控制
### 15.7.1 虚析构函数
### 15.7.2 合成拷贝控制与继承
### 15.7.3 派生类的拷贝控制成员
### 15.7.4 继承的构造函数
## 15.8 容器与继承
## 15.9 再探文本查询
