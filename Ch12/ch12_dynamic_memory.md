# 动态内存
- 静态内存，程序启动到程序运行结束都存在，全局变量与静态变量
- 栈内存，局部变量
- 堆内存，动态分配的内存
## 12.1 动态内存与智能指针
动态内存的管理由两个运算符完成：
- new：为对象分配空间并返回一个指向内存的指针。可选择是否初始化对象
- delete：接受一个指向对象的指针，析构对象，收回分配的空间

如果分配类内存而忘记收回，会造成内存泄漏，如果对象还在使用就收回了空间，产生引用非法内存的指针。
智能指针：自动释放内存，有两种：shared_ptr允许多个指针指向同一个对象，unique_ptr独占一个对象。还有一种weak_ptr，弱引用，指向shared_ptr所指向的对象。
### 12.1.1 shared_ptr类
- make_shared()函数
这是最安全的分配内存方法。
### 12.1.2 直接管理内存
- 使用new动态分配和初始化对象
```
int *a = new int;  //默认初始化
int *a = new int();  //值初始化
```
- 动态分配的const对象
new返回的指针是一个指向const的指针。
- 内存耗尽
- 释放动态内存
- 指针值和delete
传递给delete的指针必须指向动态分配的内存或者是一个空指针。
释放非动态分配的内存或者同一个指针delete多次其行为是未定义的。
- 动态对象的生存期直到被释放为止
- delete之后要重置指针值
delete后，指针成为空悬指针，如果此时再次使用指针，将产生未定义的行为，因此需要将指针重置为0或nullptr。但只是提供了有限的保护，如果有多个指针指向这个对象，则需要分别重置，非常容易出错。
### 12.1.3 shared_ptr和new结合使用
`shared_ptr<int> p2(new int(1024));`
- 不要混合使用普通指针和智能指针
智能指针是自动管理内存，很难确定他何时释放内存，因此混用是十分危险的。
- 也不要使用get初始化另一个智能指针或为智能指针赋值
新的智能指针会自动管理原来指针所指内存，自动的delete行为将原来的智能指针所指向的内存释放。这会导致两个后果，原来的智能指针内部的指针成为空悬指针，而且原智能指针销毁时会二次释放内存。
- 其他shared_ptr操作
### 12.1.4 智能指针和异常

