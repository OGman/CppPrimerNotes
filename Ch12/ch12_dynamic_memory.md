# 动态内存
- 静态内存，程序启动到程序运行结束都存在，全局变量与静态变量
- 栈内存，局部变量
- 堆内存，动态分配的内存
## 12.1 动态内存与智能指针
动态内存的管理由两个运算符完成：
- new：为对象分配空间并返回一个指向内存的指针。可选择是否初始化对象
- delete：接受一个指向对象的指针，析构对象，收回分配的空间

如果分配类内存而忘记收回，会造成内存泄漏，如果对象还在使用就收回了空间，产生引用非法内存的指针。
智能指针：自动释放内存，有两种：shared_ptr允许多个指针指向同一个对象，unique_ptr独占一个对象。还有一种weak_ptr，弱引用，指向shared_ptr所指向的对象。
### 12.1.1 shared_ptr类
- make_shared()函数
这是最安全的分配内存方法。
### 12.1.2 直接管理内存
- 使用new动态分配和初始化对象
```
int *a = new int;  //默认初始化
int *a = new int();  //值初始化
```
- 动态分配的const对象
new返回的指针是一个指向const的指针。
- 内存耗尽
- 释放动态内存
- 指针值和delete
传递给delete的指针必须指向动态分配的内存或者是一个空指针。
释放非动态分配的内存或者同一个指针delete多次其行为是未定义的。
- 动态对象的生存期直到被释放为止
- delete之后要重置指针值
delete后，指针成为空悬指针，如果此时再次使用指针，将产生未定义的行为，因此需要将指针重置为0或nullptr。但只是提供了有限的保护，如果有多个指针指向这个对象，则需要分别重置，非常容易出错。
### 12.1.3 shared_ptr和new结合使用
`shared_ptr<int> p2(new int(1024));`
- 不要混合使用普通指针和智能指针
智能指针是自动管理内存，很难确定他何时释放内存，因此混用是十分危险的。
- 也不要使用get初始化另一个智能指针或为智能指针赋值
新的智能指针会自动管理原来指针所指内存，自动的delete行为将原来的智能指针所指向的内存释放。这会导致两个后果，原来的智能指针内部的指针成为空悬指针，而且原智能指针销毁时会二次释放内存。
- 其他shared_ptr操作
### 12.1.4 智能指针和异常
异常处理保证程序在局部出错时还能正常进行，但出现异常时要保证代码内的资源被正常的释放，只能指针能够很好地做到这一点。
- 智能指针和哑类
没有定义良好析构函数的类容易造成资源的泄漏，可以使用只能指针来管理之种类。
- 使用我们自己的释放操作
自定义删除器，必须是接受类型为对应指针参数的函数。构造智能指针时，将删除器作为参数传入。
### 12.1.5 unique_ptr
`unique_ptr<string> p1(new string("hello"));`
unique_ptr不能拷贝。可以通过release和reset将其内部指针的控制权转移给另一个智能指针。
- 传递unique_ptr对象和返回unique_ptr
可以拷贝或复制一个即将销毁的unique_ptr。
- 向unique_ptr返回删除器
### 12.1.6 weak_ptr
weak_ptr指向shared_ptr指向的对象，但不改变shared_ptr的引用计数，因此，使用weak_ptr可以保证shared_ptr的安全，weak_ptr不能直接使用，因为他所管理的内存很可能被别人释放掉。使用时必须lock来判断其指向的对象是否存在。
- 核查指针类
## 12.2 动态数组
### 12.2.1 new和数组
`int *pia = new int[n]`
- 分配一个数组会得到一个元素类型的指针
动态数组不是数组类型，不能使用begin(), end()
- 初始化动态分配对象的数组
默认情况下，new分配的对象是默认初始化的，在后面加()后进行值初始化。
- 动态分配一个空数组是合法的
返回一个合法的非空指针，但又不指向任何元素。
- 释放动态数组
`delete [] p;`
- 智能指针和动态数组
标准库提供了一个可以管理动态数组的unique_ptr: `unique_ptr<int[]> up(new int[10] ());`，调用release()时，会自动调用delete[]。
还可以直接使用下标方位元素。
### 12.2.2 allocator类
new将分配内存和构造对象组合在一起，灵活性有局限。当我们分配单个对象时，分配内存和初始化一般放在一起。但当我们分配大块内存时，一般是计划在这块内存上按需构造对象。另外，没有默认构造函数的类不能动态分配数组。
- allocator类
allocator是一个模板，要提供需要分配的类型，对象分配内存时按照类型分配合适的大小和对齐位置。allocator分配的是原始未构造的内存。
```
allocator<string> alloc;
auto const p = alloc.allocate(n);
```
- allocator分配未构造的内存
对于未构造的内存，我们必须用construct来构造对象
```
auto q = p;
alloc.construct(q++);
alloc.construct(q++, "hello");
```
对象使用完后，要用destroy来进行销毁。
```
while (q != p)
  alloc.destroy(--q);
```
使用deallocate释放内存，`alloc.deallocate(p, n)`
问题：使用了一部分可以将未使用的部分释放吗。
- 拷贝和填充未初始化内存的算法
```
uninitialized_copy(b, e, b2) //区间
uninitialized_copy_n(b, n, b2)  //个数
uninitialized_fill(b, e, t)
uninitialized_fill_n(b, n, t)
```
返回值为构造完成的最后一个元素后面的迭代器
## 12.3 使用标准库：文本查询程序
