# 拷贝控制
## 13.1 拷贝、赋值与销毁
### 13.1.1 拷贝构造函数
如果一个构造函数其第一个参数是所属类类型的引用，且其他参数都有默认值，则这个构造函数是拷贝构造函数。
拷贝构造函数的参数必须是所属类类型的引用。
- 合成拷贝构造函数
即使我们定义了其他拷贝构造函数，编译器也会为我们定义一个。
- 拷贝初始化
拷贝初始化不仅在使用=定义变量时发生。以下情况也会发生：
1. 传递一个非引用的形参
2. 返回一个非引用的对象
3. 用列表初始化数组或聚合类的成员
- 参数和返回值
- 拷贝初始化的限制
-编译器可以绕过拷贝构造函数
可以略过但仍需要提供拷贝构造函数。
### 13.1.2 拷贝赋值运算符
- 重载赋值运算符
重载运算符本质上是函数。需要返回类型和参数列表。
某些运算符包括成员函数必须定义为成员函数，定义为成员函数的运算符其左侧运算对象绑定到this指针。
赋值运算符一般返回其左侧运算对象的引用。标准库通常要求保存在容器中的类型有赋值运算符，且返回值为左侧运算对象的引用。
- 合成拷贝赋值运算符
### 13.1.3 析构函数
构造函数初始化非static数据成员。析构函数释放对象使用的资源，并销毁非static数据成员。
析构函数：
```
class Foo
{
  ~Foo();
};
```
由于析构函数不接受参数，因此它不能被重载。一个类只能有唯一一个析构函数。
- 析构函数做什么工作
- 什么时候会调用析构函数
对象被销毁的时候执行析构函数：
1. 变量在离开其作用域时被销毁
2. 类的对象被销毁时，其成员被销毁
3. 容器被销毁时，其元素被销毁
4. 动态分配对象的指针使用delete时，对象被销毁
5. 临时对象当语句执行完毕时被销毁
### 13.1.4 三/五法则
### 13.1.5 使用=default
### 13.1.6 阻止拷贝
- 定义删除的函数
```
struct Nocopy {
  Nocopy() = default;
  Nocopy(const Nocopy&) = delete;
  Nocopy &operator=(const Nocopy&) = delete;
  ~Nocopy() = default;
}
```
- 析构函数不能是删除的成员
析构函数如果是删除的成员，则对象无法被销毁。对于没有析构函数的类，编译器不允许创建对象。不允许定义该类的变量和创建临时对象。如果一个类的成员类型删除了析构函数，则无法定义该类型
- 合成的拷贝控制成员可能是删除的
如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。
- private拷贝控制
可以通过将拷贝构造函数声明为private来阻止拷贝，此时用户代码无法拷贝这个对象，但是友元和成员函数可以，我们将这些拷贝控制成员声明但不去定义它们，这样一旦执行拷贝操作，在链接阶段就会报出未定义的函数的错误。
声明一个成员函数但不去定义它是合法的。
用=delete的方法更先进
## 13.2 拷贝控制和资源管理
通常，定义类外资源的类必须定义拷贝控制成员。一旦一个类需要析构函数，则他一定需要一个拷贝构造函数和一个拷贝赋值运算符。一般来说，拷贝的方式有两种可选类型：使类的行为看起来像一个值或者像一个指针。类的行为像值则类在拷贝时会将内部所有的资源拷贝出一份新的，传递给新的对象，原对象与新的对象相互独立。像指针则将原有的资源传递给新的对象，二者的部分数据是共享的。
### 13.2.1 行为像值的类




