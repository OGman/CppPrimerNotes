# 类
类：定义自己的数据结构，来表示问题中的各种概念。
类的基本思想是数据抽象和封装。
    - 数据抽象：将数据类型抽象为对外的接口和对内的实现，接口是指用户可以使用的各种函数，实现指的是内部的数据，内部函数，以及对外接口函数体。
    - 封装：将接口与实现分离开来，隐藏实现，暴露接口。
    
类的设计者负责考虑实现，类的使用者只需要考虑接口的使用方法。

## 7.1 定义抽象数据类型

### 7.1.1 设计Sales_data类
    讲了之前章节中出现过的设计场景，说明本节使用的类需要哪些接口和如何使用。
### 7.1.2 定义改进的Sales_data类
    成员函数必须在类内声明，但定义既可以在类内也可以在类外。定义在类内的函数是隐式的inline函数。
    在类内部使用类的成员时，隐式地使用了this指针。this指针是常量指针，指向调用方法的对象。this指针中保存的地址是在调用方法时由编译器传入的，传入的是对象的地址。
        *常量指针即顶层指针，指针内存放的地址不能改变。
    常量成员函数，声明时在参数列表后加const，这个const表示传入的this指针为指向常量的常量指针。常量对象、指向常量对象的指针和引用只能调用常量成员函数。
    编译器编译类时，先编译成员的声明，然后才编译成员函数体。所以可以定义函数的时候可以函数体内可以使用后面定义的成员。
### 7.1.3 定义类相关的非成员函数
    一般来说，如果非类成员函数是类接口的组成部分，应该将这些函数与类声明放在同一头文件内。
    io类不能被拷贝，只能通过引用来传递。
    一般来说，拷贝类的对象一般是拷贝类的数据成员。
### 7.1.4 构造函数
    构造函数：初始化对象
    默认构造函数可以用=default声明。
    构造函数不能是常成员函数。不同构造函数必须在参数数量或参数类型上有所区别。
    未提供构造函数时，编译器会创建默认构造函数。默认构造函数初始化对象的规则是：
        如果类内有初始值，则使用类内初始值初始化。
        如果没有，进行默认初始化。
        
## 7.2 访问控制与封装
1. public与private：
    public后的成员用户可以访问，用来暴露接口
    private后的成员可以被类的成员函数访问，不能被用户访问
2. class与struct的区别
    class默认的成员为private，struct默认成员为public
### 7.2.1 友元
    当需要类外的代码访问类的private变量时，使用友元。由于函数需要在类内部进行声明，声明时在前面加friend
    封装优点:
    - 低耦合，调整类的实现时，不需要修改用户的代码
    - 防止用户随意修改类的数据
    友元函数声明：在类内声明只表示有访问私有成员的权限，不算真正意义的函数声明，因此在类外还需要对友元函数作正式声明。友元函数的声明一般与类声明放在同一个头文件内。
## 7.3 类的其它特性
### 7.3.1 类成员再探
- 定义类型成员
    `typedef std::string::size_type pos;`需要类外的函数使用的类型成员要声明为public，类型成员必须先声明后使用。
- 令成员作为内联函数
    函数声明或定义前加inline修饰符，既可以在类内声明，也可以在类外，建议在类外函数定义前声明。
- 重载成员函数
    函数参数类型和/或个数必须不同
- 可变数据成员
    mutable可变数据成员，永远可变的数据成员，即使是const对象，他的mutable成员也是可改变的，const成员函数可以改变mutable成员变量的值
- 类数据成员的初始值
    类内初始值必须使用=或{}初始化
### 7.3.2 返回*this的成员函数
    返回*this的成员函数可以完成一系列嵌套的动作：
    `myScreen.set().move(4,0)`
    
    const成员函数返回*this时，由于传入的this指针为指向常量的指针，返回的对象是一个常量
### 7.3.3 类类型
每个类定义了唯一的类型，即使两个类包含的成员完全一样也是不同的类型。
### 7.3.4 友元再探
- 友元类
    在类内声明友元类：`friend class Window_manager`
    类的友元关系不具有传递性
- 成员函数作为友元
    将成员函数作为友元需要精心管理类的声明顺序，否则编译会报错，尽量不要这样做。
- 函数重载和友元
    没有关系，重载的函数本身是不同的函数，想要将一组重载函数声明为友元需要逐个进行声明。
- 友元声明和作用域
    友元函数可以定义在类中，即使定义在类中也需要在类外进行声明。
## 7.4 类的作用域
在函数外部定义类的成员函数时，在类名后面的定义都在类作用域内部，因此参数可以直接使用类内定义的类型。函数返回值在类名之前，因此在类作用域之外，返回值使用类内定义类型时，需要在前面加类名。
### 7.4.1 名字查找与类的作用域
类的定义分两步：首先编译类成员的声明，然后编译类的函数体，因此，在类的函数体内能够使用类内声明的各种名称。
- 用于类成员声明的名字查找
    声明中出现的名字，必须在使用前确保可见。
- 类型名要特殊处理
- 成员定义中的普通块作用域的名字查找
    1.块内 2.类内 3.函数定义前的作用域
- 类作用域之后，在外围的作用域中查找
- 在文件中名字的出现处对其进行解析
## 7.5构造函数再探
### 7.5.1 构造函数初始值列表
构造函数初始值列表用于在构造对象的时候对数据成员初始化，在构造函数体内赋值，相当于对数据成员先声明再赋值，对于某些特殊类型的成员必须在声明的时候就初始化，例如const成员，引用，有这类成员的类，其构造函数必须使用初始化列表。
- 成员初始化的顺序
    构造函数初始值列表初始化时，初始化的顺序为类定义中出现的顺序。
### 7.5.2 委托构造函数
用别的构造函数执行自己的构造过程：`Sales_data(): Sales_data("", 0, 0) {}`
### 7.5.3 默认构造函数的作用
当对象被默认初始化或值初始化时自动执行默认构造函数
- 使用默认构造函数：Sales_data obj;不需要加括号
### 7.5.4 隐式的类类型转换
只接受一个实参的构造函数定义了一条参数类型到所定义类型的隐式类类型转换规则
编译器只允许一步类类型转换
隐式类型转换有时并不需要，可以用explict来避免： `explicit Sales_data(std::istream& is);`



