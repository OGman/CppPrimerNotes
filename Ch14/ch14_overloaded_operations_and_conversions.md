# 重载运算与类型转换
## 14.1 基本概念
重载运算符是具有特殊名字的函数，由关键字operator和后面的符号构成。
如果运算符函数是成员函数，则其第一个操作数与this指针隐式绑定。
运算符函数必须与特定类型相关联。
重载运算符的优先级和结合律与原运算符相同。
- 直接调用一个重载的运算符函数
非成员函数
```
data1+data2;
operator+(data1, data2);
```
成员函数
```
data1 += data2;
data1.operator+(data2);
```
- 某些运算符不应该被重载
通常不应重载, & && ||运算符

- 使用与内置类型一致的含义
重载运算符很大程度上让类的理解和使用更加方便直观。
如果定义了==一般也需要定义!=
如果定义了<一般也需要定义其他关系运算符

- 赋值和复合赋值运算符
重载赋值运算符应返回其左侧运算对象的一个引用，复制之后，左侧对象应该与右侧对象值相等
如果有算术运算符则最到定义对应的复合赋值运算符+=,\*=等
- 选择作为成员或者非成员
在重载运算符时，首先要确定是作为成员还是非成员。
1. 赋值、下标、调用和成员访问（->）必须是成员
2. 复合赋值运算符一般来说应为成员，但非必须
3. 改变对象状态的运算符一般应为成员
4. 具有对称性的运算符通常应该是非成员函数
## 14.2 输入和输出运算符
### 14.2.1 重载输出运算符<<
输出运算符有两个参数，第一个参数是一个非常量的ostream对象的引用，非常量是因为向流写入数据会改变它的状态，引用是因为我们无法复制ostream对象；第二个参数是一个想要输出对象的常量引用，常量是因为我们不会改变他的值，引用是为了避免复制数据；返回值是它的ostream形参，这是为了与内置的输出运算符保持一致。
- Sales_data的输出运算符
```C++
ostream &operator(ostream &os, const Sales_data &item)
{
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}
```
- 输出运算符尽量减少格式化操作
为了保留用户使用输出运算符输出内容格式的自由度，尽量不要在输出运算符内进行格式化操作，比如加换行符或者对齐等。
- 输入输出运算符必须是非成员函数
如果写成成员函数，则运算符的第一个参数为this指针，无法进行输入输出，因此输入输出运算符不能被声明为成员函数。为了能够访问类内私有成员，一般将其声明为友元函数。
### 14.2.2 重载输入运算符>>
输入运算符有两个参数，第一个为非常量的istream的引用，第二个为非常量的输入类型的对象的引用，非常量是因为我们要将数据写入到这个对象中。
- Sales_data的输入运算符
```C++
istream &operator(istream &is, Sale_data &item)
{
  is >> item.bookNo >> item.units_sold >> price;
  if (is)
    item.revenue = item.units_sold*price;
  else
    item = Sales_data();
  return is;
}
```
- 输入时的错误
常见的错误有两种：
1. 读取的内容跟存储的对象不符
2. 读取到达文件末尾或者遇到留的其他错误
我们必须保证，在发生错误时，产生的结果仍然是合法的并且最好不产生误导，因此，如果读取失败，我们将item置为Sales_data默认初始化的值。
- 标示错误
最好的方式是有IO标准库来标识这些错误。
## 14.3 算术和关系运算符
我们通常把算术和关系运算符定义为非成员函数，因为这样更方便对左侧或右侧的运算对象进行转换。参数一般为常量，因为不需要改变左右操作数的值。返回值一般都是一个新的对象，在函数体中建立局部对象，最后返回对这个对象的拷贝。
由于定义算术运算符时，一般也需要定义对应的复合赋值运算符，因此算数运算符的实现一般直接使用复合赋值运算符。
```C++
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
  Sales_data sum = lhs;
  sum += rhs;
  return sum;
}
```
### 14.3.1 相等运算符
相等运算符应该比较每个数据成员，当他们都相等时，才认为两个对象相等。
```C++
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
  return lhs.isbn() == rhs.isbn() &&
         lhs.units_sold == rhs.units_sold &&
         lhs.revenue == rhs.revenue;
}
bools operator!=(cosnt Sales_data &lhs, cosnt Sales_data &rhs)
{
  return !(lhs == rhs);
}
```
设计准则：
1. 如果类需要比较是否相等的操作，则应该将它定义为==运算符
2. 如果定义了==，则应该能用它判断一组给定对象中是否有重复数据
3. ==应该有传递性
4. 定义==则也应该定义!=
5. ==与!=应该将其中一个的工作委托给另外一个
### 14.3.2 关系运算符
关系运算符通常应该：
1. 定义顺序关系，令其与关联容器中对关键字的要求一致
2. 如果同时有==运算符，则关系运算符应该与==保持匹配：如果两个对象是!=的则一个应<另一个
## 14.4 赋值运算符
拷贝赋值运算符与移动赋值运算符将类的一个对象复制给另一个对象。我们也可以定义别的运算符，将其他类的对象赋值给本类。

- 复合赋值运算符
复合赋值运算符不一定必须是类成员，但我们还是习惯于将包括复合赋值运算符在内的所有赋值运算符包含在类内。符合赋值运算符返回其左侧运算对象的引用。
```C++
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this;
}
```
## 14.5 下标运算符
## 14.6 递增和递减运算符
## 14.7 成员访问运算符
## 14.8 函数调用运算符
### 14.8.1 lambda是函数对象
### 14.8.2 标准库定义的函数对象
### 14.8.3 可调用对象与function
## 14.9 重载、类型转换与运算符
### 14.9.1 类型转换运算符
### 14.9.2 避免有二义性的类型转换
### 14.9.3 函数匹配与重载运算符
